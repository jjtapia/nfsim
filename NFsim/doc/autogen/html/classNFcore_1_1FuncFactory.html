<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>NFsim: NFcore::FuncFactory Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.4 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul>
</div>
<div class="nav">
<a class="el" href="namespaceNFcore.html">NFcore</a>::<a class="el" href="classNFcore_1_1FuncFactory.html">FuncFactory</a></div>
<h1>NFcore::FuncFactory Class Reference</h1><!-- doxytag: class="NFcore::FuncFactory" --><code>#include &lt;<a class="el" href="NFfunction_8hh-source.html">NFfunction.hh</a>&gt;</code>
<p>

<p>
<a href="classNFcore_1_1FuncFactory-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
Parses mathmatical functions that can be easily used anywhere. 
<p>
Built from the muParser freeware package, this factory creates Parser objects that can be used to evaluate arbitrary functions. The function to evaluate is given as a string (which can contain the given functions or constants below, case sensitive) along with pointers to particular varables that exist. The Parser, when initialized, translates the string into bytecode that can be evaluated fast. At runtime, the bytecode that was created can be evaluated and every time it is evaluated, it uses the current value of the given pointers to variables. Thus, NFsim can use functions of arbitrary complexity for defining reaction rates and parameters.<p>
<b>Supported functions:</b> <table border="0>" cellspacing="3" cellpadding="3">
<tr>
<td>name&amp;nbsp&amp;nbsp</td><td>n_args&amp;nbsp&amp;nbsp</td><td>description </td></tr>
<tr>
<td>sin</td><td>1</td><td>sine function (arg is in radians) </td></tr>
<tr>
<td>cos</td><td>1</td><td>cosine function </td></tr>
<tr>
<td>tan</td><td>1</td><td>tangens function </td></tr>
<tr>
<td>asin</td><td>1</td><td>arcus sine function </td></tr>
<tr>
<td>acos</td><td>1</td><td>arcus cosine function </td></tr>
<tr>
<td>atan</td><td>1</td><td>arcus tangens function </td></tr>
<tr>
<td>sinh</td><td>1</td><td>hyperbolic sine function </td></tr>
<tr>
<td>cosh</td><td>1</td><td>hyperbolic cosine </td></tr>
<tr>
<td>tanh</td><td>1</td><td>hyperbolic tangens function </td></tr>
<tr>
<td>asinh</td><td>1</td><td>hyperbolic arcus sine function </td></tr>
<tr>
<td>acosh</td><td>1</td><td>hyperbolic arcus tangens function </td></tr>
<tr>
<td>atanh</td><td>1</td><td>hyperbolic arcur tangens function </td></tr>
<tr>
<td>log2</td><td>1</td><td>logarithm to the base 2 </td></tr>
<tr>
<td>log10</td><td>1</td><td>logarithm to the base 10 </td></tr>
<tr>
<td>log</td><td>1</td><td>logarithm to the base 10 </td></tr>
<tr>
<td>ln</td><td>1</td><td>logarithm to base e (2.71828...) </td></tr>
<tr>
<td>exp</td><td>1</td><td>e raised to the power of x </td></tr>
<tr>
<td>sqrt</td><td>1</td><td>square root of a value </td></tr>
<tr>
<td>sign</td><td>1</td><td>sign function -1 if x&lt;0; 1 if x&gt;0 </td></tr>
<tr>
<td>rint</td><td>1</td><td>round to nearest integer </td></tr>
<tr>
<td>abs</td><td>1</td><td>absolute value </td></tr>
<tr>
<td>if</td><td>3</td><td>if ... then ... else ... </td></tr>
<tr>
<td>min</td><td>var.</td><td>min of all arguments </td></tr>
<tr>
<td>max</td><td>var.</td><td>max of all arguments </td></tr>
<tr>
<td>sum</td><td>var.</td><td>sum of all arguments </td></tr>
<tr>
<td>avg</td><td>var.</td><td>mean value of all arguments </td></tr>
</table>
<p>
<b>Supported constants</b> (to a precision of at least 10^-8): <table border="0>" cellspacing="3" cellpadding="3">
<tr>
<td>name&amp;nbsp&amp;nbsp</td><td>value&amp;nbsp&amp;nbsp</td><td>description </td></tr>
<tr>
<td>_PI</td><td>3.141...</td><td>you all know pi, right? </td></tr>
<tr>
<td>_e</td><td>2.718...</td><td>the base of natural logs </td></tr>
<tr>
<td>_Na</td><td>6.022...e23</td><td>Avogadro's number </td></tr>
</table>
<p>
For muParser documentation, see: <a href="http://muparser.sourceforge.net/">http://muparser.sourceforge.net/</a> <table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static mu::Parser *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNFcore_1_1FuncFactory.html#77b38df3330c3b4b9247e55377016da4">create</a> (string function, vector&lt; string &gt; &amp;variableNames, vector&lt; double * &gt; &amp;variablePtrs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static mu::Parser *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNFcore_1_1FuncFactory.html#06027d4126ce96a32c7ce001ad7cb733">create</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNFcore_1_1FuncFactory.html#31bc4b8afdd056b59e80e55dbd28715a">Eval</a> (mu::Parser *p)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNFcore_1_1FuncFactory.html#e3bba8b455353e58dabe2add83a1aeae">test</a> ()</td></tr>

</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="77b38df3330c3b4b9247e55377016da4"></a><!-- doxytag: member="NFcore::FuncFactory::create" ref="77b38df3330c3b4b9247e55377016da4" args="(string function, vector&lt; string &gt; &amp;variableNames, vector&lt; double * &gt; &amp;variablePtrs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parser * FuncFactory::create           </td>
          <td>(</td>
          <td class="paramtype">string&nbsp;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>variableNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>variablePtrs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Use this function to create a new function parser that can operate on the given variables. The vectors should contain (in the same order) the variable names and pointers to the actual variable values. Do not use local variables or variables that will be forgotten before the Parser is destroyed. To evaluate functions, you can either just call the <a class="el" href="classNFcore_1_1FuncFactory.html#31bc4b8afdd056b59e80e55dbd28715a">Eval()</a> function of the Parser object (as in p-&gt;<a class="el" href="classNFcore_1_1FuncFactory.html#31bc4b8afdd056b59e80e55dbd28715a">Eval()</a>), or, call the Eval function of <a class="el" href="classNFcore_1_1FuncFactory.html" title="Parses mathmatical functions that can be easily used anywhere.">FuncFactory</a> to do error checking (as in FuncFactory::Eval(p)). 
</div>
</div><p>
<a class="anchor" name="06027d4126ce96a32c7ce001ad7cb733"></a><!-- doxytag: member="NFcore::FuncFactory::create" ref="06027d4126ce96a32c7ce001ad7cb733" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parser * FuncFactory::create           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a function without any variables and without any functions defined. You will have to do that yourself. But, this does add in any predefined constants we want, and that is why this function exists. 
</div>
</div><p>
<a class="anchor" name="31bc4b8afdd056b59e80e55dbd28715a"></a><!-- doxytag: member="NFcore::FuncFactory::Eval" ref="31bc4b8afdd056b59e80e55dbd28715a" args="(mu::Parser *p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double FuncFactory::Eval           </td>
          <td>(</td>
          <td class="paramtype">mu::Parser *&nbsp;</td>
          <td class="paramname"> <em>p</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Evaluates the given Parser object safely, meaning exceptions and errors are caught and program execution is terminated - if you have to do better than simple program termination, well than you can catch your own errors (see the muParser documenation). 
</div>
</div><p>
<a class="anchor" name="e3bba8b455353e58dabe2add83a1aeae"></a><!-- doxytag: member="NFcore::FuncFactory::test" ref="e3bba8b455353e58dabe2add83a1aeae" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FuncFactory::test           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Runs a couple tests of the <a class="el" href="classNFcore_1_1FuncFactory.html" title="Parses mathmatical functions that can be easily used anywhere.">FuncFactory</a> and the muParser functions to make sure everything is working as promised. (To run this, use the arguements '-test mathFuncParser') 
</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>/home/msneddon/eclipse/galileoSR1_cpp/workspace/NFsim/src/NFfunction/<a class="el" href="NFfunction_8hh-source.html">NFfunction.hh</a><li>/home/msneddon/eclipse/galileoSR1_cpp/workspace/NFsim/src/NFfunction/<a class="el" href="funcParser_8cpp.html">funcParser.cpp</a></ul>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Dec 9 11:02:48 2010 for NFsim by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.4 </small></address>
</body>
</html>
