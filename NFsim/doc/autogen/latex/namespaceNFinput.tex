\section{NFinput Namespace Reference}
\label{namespaceNFinput}\index{NFinput@{NFinput}}


\subsection{Detailed Description}
Functionality to handle input from XML files or command line arguments. 

This is a very straightforward set of functions and simple classes that together parse and handle all the major input into NFsim. The raw XML parsing code comes from the TinyXML project and can be found in its unedited form in the TinyXML directory. Thanks TinyXML! You perform great and you are definitely tiny! \begin{Desc}
\item[Author:]Michael Sneddon \end{Desc}




\subsection*{Classes}
\begin{CompactItemize}
\item 
class {\bf component}
\begin{CompactList}\small\item\em Maintains information about a \doxyref{component}{p.}{classNFinput_1_1component} of a TemplateMolecule. \item\end{CompactList}\end{CompactItemize}
\subsection*{Functions}
\begin{CompactItemize}
\item 
bool {\bf parseArguments} (int argc, const char $\ast$argv[$\,$], map$<$ string, string $>$ \&argMap)
\begin{CompactList}\small\item\em Parses command line arguments from the console nicely. \item\end{CompactList}\item 
int {\bf parseAsInt} (map$<$ string, string $>$ \&argMap, string argName, int defaultValue)
\begin{CompactList}\small\item\em Looks up the argument in the argMap and tries to parse the value as an integer. \item\end{CompactList}\item 
double {\bf parseAsDouble} (map$<$ string, string $>$ \&argMap, string argName, double defaultValue)
\begin{CompactList}\small\item\em Looks up the argument in the argMap and tries to parse the value as a double. \item\end{CompactList}\item 
bool {\bf parseSequence} (string numString, vector$<$ double $>$ \&outputTimes)
\begin{CompactList}\small\item\em Parses a matlab style sequence (ie startValue:step:endValue) into the vector. \item\end{CompactList}\item 
bool {\bf createSystemDumper} (string paramStr, {\bf System} $\ast$s, bool verbose)
\begin{CompactList}\small\item\em Parses the cmd line arg that specifies system dumps, and schedules them. \item\end{CompactList}\item 
{\bf System} $\ast$ {\bf initializeFromXML} (string filename, bool blockSameComplexBinding, int globalMoleculeLimit, bool verbose)
\begin{CompactList}\small\item\em Maintains information about a \doxyref{component}{p.}{classNFinput_1_1component} of a TemplateMolecule. \item\end{CompactList}\item 
bool {\bf initParameters} ({\bf TiXmlElement} $\ast$pListOfParameters, {\bf System} $\ast$s, map$<$ string, double $>$ \&parameter, bool verbose)
\begin{CompactList}\small\item\em Reads the parameter XML block and puts them in the parameter map. \item\end{CompactList}\item 
bool {\bf initMoleculeTypes} ({\bf TiXmlElement} $\ast$pListOfMoleculeTypes, {\bf System} $\ast$system, map$<$ string, int $>$ \&allowedStates, bool verbose)
\begin{CompactList}\small\item\em Reads the MoleculeType XML block and adds the MoleculeTypes to the system. \item\end{CompactList}\item 
bool {\bf initStartSpecies} ({\bf TiXmlElement} $\ast$pListOfSpecies, {\bf System} $\ast$system, map$<$ string, double $>$ \&parameter, map$<$ string, int $>$ \&allowedStates, bool verbose)
\begin{CompactList}\small\item\em Reads a Species XML block, creates the molecules and adds them to the system. \item\end{CompactList}\item 
bool {\bf initReactionRules} ({\bf TiXmlElement} $\ast$pListOfReactionRules, {\bf System} $\ast$system, map$<$ string, double $>$ \&parameter, map$<$ string, int $>$ \&allowedStates, bool blockSameComplexBinding, bool verbose)
\begin{CompactList}\small\item\em Reads a reactionRule XML block and adds the rules to the system. \item\end{CompactList}\item 
bool {\bf readObservableForTemplateMolecules} ({\bf TiXmlElement} $\ast$pObs, string observableName, vector$<$ {\bf TemplateMolecule} $\ast$ $>$ \&tmList, vector$<$ string $>$ \&stochRelation, vector$<$ int $>$ \&stochQuantity, {\bf System} $\ast$s, map$<$ string, double $>$ \&parameter, map$<$ string, int $>$ \&allowedStates, int obsType, bool verbose)
\item 
bool {\bf initObservables} ({\bf TiXmlElement} $\ast$pListOfObservables, {\bf System} $\ast$system, map$<$ string, double $>$ \&parameter, map$<$ string, int $>$ \&allowedStates, bool verbose)
\begin{CompactList}\small\item\em Reads an observable XML block and adds the new observables to the system. \item\end{CompactList}\item 
{\bf TemplateMolecule} $\ast$ {\bf readPattern} ({\bf TiXmlElement} $\ast$pListOfMol, {\bf System} $\ast$s, map$<$ string, double $>$ \&parameter, map$<$ string, int $>$ \&allowedStates, string patternName, map$<$ string, {\bf TemplateMolecule} $\ast$ $>$ \&templates, map$<$ string, {\bf component} $>$ \&comps, map$<$ string, {\bf component} $>$ \&symMap, bool verbose)
\begin{CompactList}\small\item\em Reads a pattern XML block and returns the set of new TemplateMolecule objects. \item\end{CompactList}\item 
bool {\bf readProductPattern} ({\bf TiXmlElement} $\ast$pListOfMol, {\bf System} $\ast$s, map$<$ string, double $>$ \&parameter, map$<$ string, int $>$ \&allowedStates, string patternName, vector$<$ {\bf MoleculeType} $\ast$ $>$ \&productMoleculeTypes, vector$<$ vector$<$ int $>$ $>$ \&stateInformation, vector$<$ vector$<$ int $>$ $>$ \&bindingSiteInformation, bool verbose)
\begin{CompactList}\small\item\em Reads a pattern XML block and returns the set of new TemplateMolecule objects. \item\end{CompactList}\item 
bool {\bf initFunctions} ({\bf TiXmlElement} $\ast$pListOfFunctions, {\bf System} $\ast$system, map$<$ string, double $>$ \&parameter, {\bf TiXmlElement} $\ast$pListOfObservables, map$<$ string, int $>$ \&allowedStates, bool verbose)
\begin{CompactList}\small\item\em Reads the Function XML block and adds the Functions to the system. \item\end{CompactList}\item 
bool {\bf FindReactionRuleSymmetry} ({\bf TiXmlElement} $\ast$pRxnRule, {\bf System} $\ast$s, map$<$ string, double $>$ \&parameter, map$<$ string, int $>$ \&allowedStates, map$<$ string, {\bf component} $>$ \&symComps, map$<$ string, {\bf component} $>$ \&symRxnCenter, bool verbose)
\item 
bool {\bf readPatternForSymmetry} ({\bf TiXmlElement} $\ast$pListOfMol, {\bf System} $\ast$s, string patternName, map$<$ string, {\bf component} $>$ \&comps, map$<$ string, {\bf component} $>$ \&symComps, bool verbose)
\item 
bool {\bf generateRxnPermutations} (vector$<$ map$<$ string, {\bf component} $>$ $>$ \&permutations, map$<$ string, {\bf component} $>$ \&symComps, map$<$ string, {\bf component} $>$ \&symRxnCenter, bool verbose)
\item 
bool {\bf lookup} ({\bf component} $\ast$\&c, string id, map$<$ string, {\bf component} $>$ \&comps, map$<$ string, {\bf component} $>$ \&symMap)
\item 
void {\bf walk} ({\bf System} $\ast$s)
\begin{CompactList}\small\item\em Allows the user to walk through the system with an interactive text-based program. \item\end{CompactList}\item 
bool {\bf readRNFfile} (map$<$ string, string $>$ \&argMap, vector$<$ string $>$ \&commands, bool verbose)
\item 
bool {\bf runRNFcommands} ({\bf System} $\ast$s, map$<$ string, string $>$ \&argMap, vector$<$ string $>$ \&commands, bool verbose)
\end{CompactItemize}


\subsection{Function Documentation}
\index{NFinput@{NFinput}!createSystemDumper@{createSystemDumper}}
\index{createSystemDumper@{createSystemDumper}!NFinput@{NFinput}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}bool NFinput::createSystemDumper (string {\em paramStr}, {\bf System} $\ast$ {\em s}, bool {\em verbose})}\label{namespaceNFinput_19ed804a2b6e64acebc7ad49f95498fd}


Parses the cmd line arg that specifies system dumps, and schedules them. 

This method works by parsing the argument, initializing the class DumpSystem defined in the file \doxyref{NFoutput.hh}{p.}{NFoutput_8hh}, and adding the DumpSystem to the System. \begin{Desc}
\item[Author:]Michael Sneddon \end{Desc}
\index{NFinput@{NFinput}!FindReactionRuleSymmetry@{FindReactionRuleSymmetry}}
\index{FindReactionRuleSymmetry@{FindReactionRuleSymmetry}!NFinput@{NFinput}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}bool NFinput::FindReactionRuleSymmetry ({\bf TiXmlElement} $\ast$ {\em pRxnRule}, {\bf System} $\ast$ {\em s}, map$<$ string, double $>$ \& {\em parameter}, map$<$ string, int $>$ \& {\em allowedStates}, map$<$ string, {\bf component} $>$ \& {\em symComps}, map$<$ string, {\bf component} $>$ \& {\em symRxnCenter}, bool {\em verbose})}\label{namespaceNFinput_7ee59a37c3436e333bf2e03c65b5a03e}


\index{NFinput@{NFinput}!generateRxnPermutations@{generateRxnPermutations}}
\index{generateRxnPermutations@{generateRxnPermutations}!NFinput@{NFinput}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}bool NFinput::generateRxnPermutations (vector$<$ map$<$ string, {\bf component} $>$ $>$ \& {\em permutations}, map$<$ string, {\bf component} $>$ \& {\em symComps}, map$<$ string, {\bf component} $>$ \& {\em symRxnCenter}, bool {\em verbose})}\label{namespaceNFinput_78421cba53283fd0013e43e6d35f8b47}




Output for debugging

Output for debugging \index{NFinput@{NFinput}!initFunctions@{initFunctions}}
\index{initFunctions@{initFunctions}!NFinput@{NFinput}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}bool NFinput::initFunctions ({\bf TiXmlElement} $\ast$ {\em pListOfFunctions}, {\bf System} $\ast$ {\em system}, map$<$ string, double $>$ \& {\em parameter}, {\bf TiXmlElement} $\ast$ {\em pListOfObservables}, map$<$ string, int $>$ \& {\em allowedStates}, bool {\em verbose})}\label{namespaceNFinput_bc6239da9790d1c8d2698fedd5d5b2ab}


Reads the Function XML block and adds the Functions to the system. 

\begin{Desc}
\item[Author:]Michael Sneddon \end{Desc}
\index{NFinput@{NFinput}!initializeFromXML@{initializeFromXML}}
\index{initializeFromXML@{initializeFromXML}!NFinput@{NFinput}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf System} $\ast$ NFinput::initializeFromXML (string {\em filename}, bool {\em blockSameComplexBinding}, int {\em globalMoleculeLimit}, bool {\em verbose})}\label{namespaceNFinput_f8a520e07f56df029a7784ab451f2be1}


Maintains information about a \doxyref{component}{p.}{classNFinput_1_1component} of a TemplateMolecule. 

\begin{Desc}
\item[Author:]Michael Sneddon \end{Desc}
\index{NFinput@{NFinput}!initMoleculeTypes@{initMoleculeTypes}}
\index{initMoleculeTypes@{initMoleculeTypes}!NFinput@{NFinput}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}bool NFinput::initMoleculeTypes ({\bf TiXmlElement} $\ast$ {\em pListOfMoleculeTypes}, {\bf System} $\ast$ {\em s}, map$<$ string, int $>$ \& {\em allowedStates}, bool {\em verbose})}\label{namespaceNFinput_808357527ea979c16a3581918af4f134}


Reads the MoleculeType XML block and adds the MoleculeTypes to the system. 

The strategy is to look at one MoleculeType at a time, make sure that moleculeType contains valid information, then, and only then, create it.

\begin{Desc}
\item[Author:]Michael Sneddon \end{Desc}
\index{NFinput@{NFinput}!initObservables@{initObservables}}
\index{initObservables@{initObservables}!NFinput@{NFinput}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}bool NFinput::initObservables ({\bf TiXmlElement} $\ast$ {\em pListOfObservables}, {\bf System} $\ast$ {\em system}, map$<$ string, double $>$ \& {\em parameter}, map$<$ string, int $>$ \& {\em allowedStates}, bool {\em verbose})}\label{namespaceNFinput_f70bed5f9ae20a317e3afe838e399dd3}


Reads an observable XML block and adds the new observables to the system. 

\begin{Desc}
\item[Author:]Michael Sneddon \end{Desc}
\index{NFinput@{NFinput}!initParameters@{initParameters}}
\index{initParameters@{initParameters}!NFinput@{NFinput}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}bool NFinput::initParameters ({\bf TiXmlElement} $\ast$ {\em pListOfParameters}, {\bf System} $\ast$ {\em s}, map$<$ string, double $>$ \& {\em parameter}, bool {\em verbose})}\label{namespaceNFinput_22ad4850b4679dbdff6597d602b8022d}


Reads the parameter XML block and puts them in the parameter map. 

\begin{Desc}
\item[Author:]Michael Sneddon \end{Desc}
\index{NFinput@{NFinput}!initReactionRules@{initReactionRules}}
\index{initReactionRules@{initReactionRules}!NFinput@{NFinput}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}bool NFinput::initReactionRules ({\bf TiXmlElement} $\ast$ {\em pListOfReactionRules}, {\bf System} $\ast$ {\em system}, map$<$ string, double $>$ \& {\em parameter}, map$<$ string, int $>$ \& {\em allowedStates}, bool {\em blockSameComplexBinding}, bool {\em verbose})}\label{namespaceNFinput_08903395f329bbcd8003d11bfb5baf5a}


Reads a reactionRule XML block and adds the rules to the system. 

\begin{Desc}
\item[Author:]Michael Sneddon \end{Desc}
\index{NFinput@{NFinput}!initStartSpecies@{initStartSpecies}}
\index{initStartSpecies@{initStartSpecies}!NFinput@{NFinput}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}bool NFinput::initStartSpecies ({\bf TiXmlElement} $\ast$ {\em pListOfSpecies}, {\bf System} $\ast$ {\em system}, map$<$ string, double $>$ \& {\em parameter}, map$<$ string, int $>$ \& {\em allowedStates}, bool {\em verbose})}\label{namespaceNFinput_367fa4c87ef87ba1e44294a8d6188b68}


Reads a Species XML block, creates the molecules and adds them to the system. 

\begin{Desc}
\item[Author:]Michael Sneddon \end{Desc}
\index{NFinput@{NFinput}!lookup@{lookup}}
\index{lookup@{lookup}!NFinput@{NFinput}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}bool NFinput::lookup ({\bf component} $\ast$\& {\em c}, string {\em id}, map$<$ string, {\bf component} $>$ \& {\em comps}, map$<$ string, {\bf component} $>$ \& {\em symMap})}\label{namespaceNFinput_616c16727e7f86e02affdc873c2beecd}


\index{NFinput@{NFinput}!parseArguments@{parseArguments}}
\index{parseArguments@{parseArguments}!NFinput@{NFinput}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}bool NFinput::parseArguments (int {\em argc}, const char $\ast$ {\em argv}[$\,$], map$<$ string, string $>$ \& {\em argMap})}\label{namespaceNFinput_7dfd0ae7309545a61e7824cea5146696}


Parses command line arguments from the console nicely. 

\begin{Desc}
\item[Author:]Michael Sneddon \end{Desc}
\index{NFinput@{NFinput}!parseAsDouble@{parseAsDouble}}
\index{parseAsDouble@{parseAsDouble}!NFinput@{NFinput}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}double NFinput::parseAsDouble (map$<$ string, string $>$ \& {\em argMap}, string {\em argName}, double {\em defaultValue})}\label{namespaceNFinput_e94e951f3de1d453e79d055c19dce1f4}


Looks up the argument in the argMap and tries to parse the value as a double. 

\begin{Desc}
\item[Author:]Michael Sneddon \end{Desc}
\index{NFinput@{NFinput}!parseAsInt@{parseAsInt}}
\index{parseAsInt@{parseAsInt}!NFinput@{NFinput}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int NFinput::parseAsInt (map$<$ string, string $>$ \& {\em argMap}, string {\em argName}, int {\em defaultValue})}\label{namespaceNFinput_6acf7052e7c42fd29e422ce627b42fe5}


Looks up the argument in the argMap and tries to parse the value as an integer. 

\begin{Desc}
\item[Author:]Michael Sneddon \end{Desc}
\index{NFinput@{NFinput}!parseSequence@{parseSequence}}
\index{parseSequence@{parseSequence}!NFinput@{NFinput}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}bool NFinput::parseSequence (string {\em numString}, vector$<$ double $>$ \& {\em outputTimes})}\label{namespaceNFinput_6659a912afe36c187f82add93577693c}


Parses a matlab style sequence (ie startValue:step:endValue) into the vector. 

\begin{Desc}
\item[Author:]Michael Sneddon \end{Desc}
\index{NFinput@{NFinput}!readObservableForTemplateMolecules@{readObservableForTemplateMolecules}}
\index{readObservableForTemplateMolecules@{readObservableForTemplateMolecules}!NFinput@{NFinput}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}bool NFinput::readObservableForTemplateMolecules ({\bf TiXmlElement} $\ast$ {\em pObs}, string {\em observableName}, vector$<$ {\bf TemplateMolecule} $\ast$ $>$ \& {\em tmList}, vector$<$ string $>$ \& {\em stochRelation}, vector$<$ int $>$ \& {\em stochQuantity}, {\bf System} $\ast$ {\em s}, map$<$ string, double $>$ \& {\em parameter}, map$<$ string, int $>$ \& {\em allowedStates}, int {\em obsType}, bool {\em verbose})}\label{namespaceNFinput_ce4a726c34a7ebf5ee387fd9c53fbd87}


\index{NFinput@{NFinput}!readPattern@{readPattern}}
\index{readPattern@{readPattern}!NFinput@{NFinput}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf TemplateMolecule} $\ast$ NFinput::readPattern ({\bf TiXmlElement} $\ast$ {\em pListOfMol}, {\bf System} $\ast$ {\em s}, map$<$ string, double $>$ \& {\em parameter}, map$<$ string, int $>$ \& {\em allowedStates}, string {\em patternName}, map$<$ string, {\bf TemplateMolecule} $\ast$ $>$ \& {\em templates}, map$<$ string, {\bf component} $>$ \& {\em comps}, map$<$ string, {\bf component} $>$ \& {\em symMap}, bool {\em verbose})}\label{namespaceNFinput_ad42aeae0f73436a8d83242c0593541c}


Reads a pattern XML block and returns the set of new TemplateMolecule objects. 

\begin{Desc}
\item[Author:]Michael Sneddon \end{Desc}
\index{NFinput@{NFinput}!readPatternForSymmetry@{readPatternForSymmetry}}
\index{readPatternForSymmetry@{readPatternForSymmetry}!NFinput@{NFinput}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}bool NFinput::readPatternForSymmetry ({\bf TiXmlElement} $\ast$ {\em pListOfMol}, {\bf System} $\ast$ {\em s}, string {\em patternName}, map$<$ string, {\bf component} $>$ \& {\em comps}, map$<$ string, {\bf component} $>$ \& {\em symComps}, bool {\em verbose})}\label{namespaceNFinput_60d74a003353edf262b5be31e05e68dc}


\index{NFinput@{NFinput}!readProductPattern@{readProductPattern}}
\index{readProductPattern@{readProductPattern}!NFinput@{NFinput}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}bool NFinput::readProductPattern ({\bf TiXmlElement} $\ast$ {\em pListOfMol}, {\bf System} $\ast$ {\em s}, map$<$ string, double $>$ \& {\em parameter}, map$<$ string, int $>$ \& {\em allowedStates}, string {\em patternName}, vector$<$ {\bf MoleculeType} $\ast$ $>$ \& {\em productMoleculeTypes}, vector$<$ vector$<$ int $>$ $>$ \& {\em stateInformation}, vector$<$ vector$<$ int $>$ $>$ \& {\em bindingSiteInformation}, bool {\em verbose})}\label{namespaceNFinput_7e8ab2b49a2798dc1993710ca200d331}


Reads a pattern XML block and returns the set of new TemplateMolecule objects. 

\begin{Desc}
\item[Author:]Michael Sneddon \end{Desc}
\index{NFinput@{NFinput}!readRNFfile@{readRNFfile}}
\index{readRNFfile@{readRNFfile}!NFinput@{NFinput}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}bool NFinput::readRNFfile (map$<$ string, string $>$ \& {\em argMap}, vector$<$ string $>$ \& {\em commands}, bool {\em verbose})}\label{namespaceNFinput_96c43bfa845bbf9c559cc899c17567f0}


\index{NFinput@{NFinput}!runRNFcommands@{runRNFcommands}}
\index{runRNFcommands@{runRNFcommands}!NFinput@{NFinput}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}bool NFinput::runRNFcommands ({\bf System} $\ast$ {\em s}, map$<$ string, string $>$ \& {\em argMap}, vector$<$ string $>$ \& {\em commands}, bool {\em verbose})}\label{namespaceNFinput_614dca6b7ccb8c6d75d462d24c18a58b}


\index{NFinput@{NFinput}!walk@{walk}}
\index{walk@{walk}!NFinput@{NFinput}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void NFinput::walk ({\bf System} $\ast$ {\em s})}\label{namespaceNFinput_62bbaf5f78a0e78b0b4a69a4a18df096}


Allows the user to walk through the system with an interactive text-based program. 

\begin{Desc}
\item[Author:]Michael Sneddon \end{Desc}
